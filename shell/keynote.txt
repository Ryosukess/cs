定时任务：
	创建、编辑计划任务：crontab -e [-u 用户名]
	查看计划任务：crontab -l [-u 用户名]
	删除计划任务：crontab -r [-u 用户名]
定时任务的格式： 分钟 小时日期 月份 星期 run_command   * * * * * 把“*”

设计软件：ps,ai

shell脚本有时还要判断用户输入的参数，像mkdir一样，当目录不存在则创建，若已经存在则报错，条件测试语句就能够测试特定的表达式是否成立，当条件成立时返回值为0，否则返回其他数值：
			测试语句格式：[ 条件表达式 ]  两边各有一个空格

	细分测试语句有：文件测试、逻辑测试、整数值比较、字符串比较。
文件测试：[ 操作符 文件或者目录名 ]
操作符  作用
-d       测试是否为空目录
-e 	 测试文件或目录是否存在
-f 	 判断是否为文件
-r 	 测试当前用户是否有权限读取
-w 	 测试当前用户是否有权限写入
-x 	 测试当前用户是否有执行权限
例子： [ -d /etc/fstab ]   显示上一条命令的返回值，非0则为失败，即不是目录
       [ -e /dev/cdrom ]&&echo"Exist"

逻辑测试：[表达式1]操作符[表达式2]
操作符
&&  	逻辑的与，“而且“的意思
||  	逻辑的或，“或者”的意思
！  	逻辑的否
例子： [$USER!=root]&&echo "user"
换回root用户后用加强版的判断语句，非root用户则输出user,若是root则直接输出root
整数值比较：[整数1 操作符 整数2]
操作符   作用
-eq	判断是否等于
-ne	判断是否不等于
-gt	判断是否大于
-lt 	判断是否小于
-le	判断是否等于或小于
-ge	判断是否大于或等于
字符串比较：[字符串1 操作符 字符串2]
操作符	  作用
=	比较字符串内容是否相同
!=	比较字符串内容是否不同
-z 	判断字符串内容是否为空
例子：
	[-z $String]  判断String变量是否为空值

条件测试语句：
条件测试语句能够让Shell脚本根据实际工作灵活调整工作内容，例如判断系统的状态后执行指定的工作，或创建指定数量的用户，批量修改用户密码，这些都可以让Shell脚本通过测试语句完成。
if条件语句：
if条件语句分为单分支结构、双分支结构、多分支结构，复杂度慢慢上升，但却可以让shell脚本更加的灵活
单分支结构，仅用if、then、fi 关键词组成，只有条件成立后执行
eg:
Example.sh  判断目录是否存在，若不存在则自动创建
#!/bin/bash
DIR="/media/cdrom"
if[!-e$DIR]
then
mkdir -p $DIR
fi
双分支结构，由if、then、else、fi关键词组成，做条件成立或者条件不成立的判断。
eg:
Example.sh 判断指定主机能否ping通，根据返回结果分别给予提示或警告
#!/bin/bash
ping -c 3 -i0.2-W 3 $1 &>/dev/null
if[$? -eq 0]
then
echo"Host$1 is up."
else
echo"Host$1 id down."
fi
多分支结构,由if、then、else、elif、fi关键词组成，根据多种条件成立的可能性执行不同的操作
eg:
Example.sh 判断用户输入的分数在哪个区间内，然后判定为优秀、合格、不及格
#!/bin/bash
read -p "Enteryour score(0-100):"GRADE
if[ $GRADE-ge85 ]&&[ $GRADE-le100 ];then
echo "$GRADE is Excellent"
elif[ $GRADE -ge 70 ]&&[ $GRADE-le84];then
echo"$GRADE is Pass"
else echo"$GRADE id Fail"
fi

for条件语句
	for条件语句会先读取多个不同的变量值，然后逐一执行同一组命令

Shell是人与计算机硬件的翻译官，shell作为用户与linux系统通讯的媒介，自身定义了各种参数与变量，并提供了诸如循环、分支等高级语言才有的控制结构特性
shell的工作形式分为两种：
	交互式(Interactive):用户输入一条命令，shell解释并执行一条
	批处理(Batch):用户事先编写一个Shell脚本(script)，其中包含诸多命令，sehll会一次执行完所有命令
shell脚本是将各种命令通过逻辑语句组合而成的程序，shell脚本需要用到很多的linux命令以及结合之前学习过的正则表达式、管道命令、数据流重定向等语法规则来完成任务。


vim编辑器的末行模式  :整数    跳转到该行

统计文本的行数  $wc -l

找出被限制登录用户的命令  $grep “/sbin/nologin” /etc/passwd

grep命令用于对文本进行搜索，格式为： “grep[选项][文件]”;搜索某个关键词“grep 关键词 文本文件” ：
	-b 将可执行文件当作文本文件来搜索
	-c 仅显示找到的次数
	-i 忽略大小写
	-n 显示行号
	-v 反向选择---仅列出没有“关键词”的行

rmdir 仅删除空目录，遇到目录内有文件时则报错  rm -rf 命令会删除一切

touch命令选项  -a 仅修改"访问时间" -m 仅修改"更改时间" -d 同时修改atime与mtime   -t要修改成的时间[YYMMDDHHmm] 

$touch -d "2 days ago" test  黑客执行上一条，便将访问与修改时间修改为了两天前


在linux中文件有三种时间：
	更改时间(mtime):内容修改时间(不包括权限的)
	更改权限(ctime):更改权限与属性的时间
	读取时间(atime):读取文件内容的时间

tail 用于查看纯文本文档的后N行 $tail -n 20 文件名

head 用于查看纯文本文档的前N行 $head -n 20 文件名

more 用于查看纯文本文件(较长的) $more[文件名]  -数字 预先显示的行数 -d 显示提示语句与报错信息

cat 命令用于查看纯文本文件(较短的):$cat[选项][文件名] -n 显示行号 -b 显示行号（不包括空行）-A 显示出"不可见"的字符，如空格，tab键等 

$cd -切换到上一次的目录   $cd ~ 切换到家目录   $cd .. 切换到上级目录： 

vi命令模式下  $dw  删除一个字符

向文件中首添加内容 $sed -i '1i\XXX' next.txt  ’1‘可以替换成n

$echo "asdasd">>next.txt 向文件中末行添加内容，原文件内容保存； >原文件内容不保存 

tty=teletypes、teletypewriters  pts=pseudo-terminal slave

当系统出现故障时，收集系统本地配置信息并诊断  $sosreport

$history 用于显示历史执行过的命令  $history -c 用于清空该用户在本机中执行过命令的历史记录  history默认会保存1000条执行过的命令，若要修改可直接编辑/etc/profile文件的HISTSIZE值

$last 用于查看所有系统的登入记录

$who 查看当前登入主机用户的情况

$free -m/-g  查看当前系统中内存的使用情况，分别以m为单位、以g为单位

linux vi编辑器光标快速定位：h,j,k,l 左移下移上移右移；shift+^ 所在行首字母 $(shift+4) 所在行行尾；H(shift+h) 当前屏幕首行行首；M(shift+m) 当前屏幕中间行行首；L(shift+l) 当前屏幕底行行首;G(shift+g)当前打开文件末行行首

$watch -n 1 up time 每秒刷新一次获得当前的系统负载情况，输出内容分别为系统当前时间、系统已运行时间、当前在线用户以及平均负载值

$uptime 用于获取当前系统状态信息 

查看linux正在运行的进程 $ps aux $kill pid_number

$date "+%p" 判断今天是一年中得第几天  22

date命令能够按照指定格式显示系统的时间或日期，只需键入“+”号开头的字符串指定其格式，格式如： date "+%j"  显示一年中的第几天
%t 跳格[TAB键]
%H 小时(00-23)
%i 小时(01-12)
%M 分钟(00-59)
%S 秒(00-60)
%X 相当于 %H:%M:%S
%Z 显示时区
%P 显示本地AM或者PM
%A 星期几(Sunday-Saturday)
%a 星期几(Sun-Sat)
%B 完整月份(January-December)
%b 缩写月份(Jan-Dec)
%d 日(01-31)
%j 一年中的第几天(001-366)
%m 月份(01-12)
%Y 完整的年份



